/**
 * Sample malware-like binary for testing Ghidra MCP server.
 * This is NOT actual malware - it's a test program that exhibits
 * common malware patterns for defensive security research.
 *
 * Compile with: gcc -o test_malware test_malware.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Simulated malware structures
typedef struct {
    char *name;
    char *value;
    int offset;
} ConfigEntry;

typedef enum {
    MODE_IDLE = 0,
    MODE_SCAN = 1,
    MODE_EXFIL = 2,
    MODE_PERSIST = 3
} OperationMode;

// Simulated crypto function
void xor_encrypt(unsigned char *data, size_t len, unsigned char key) {
    for (size_t i = 0; i < len; i++) {
        data[i] ^= key;
    }
}

// Simulated C2 communication
int connect_c2(const char *server) {
    printf("[*] Connecting to C2: %s\n", server);
    // In real malware, this would use socket(), connect(), etc.
    return 0;
}

// Simulated data exfiltration
int exfiltrate_data(const char *data) {
    printf("[*] Exfiltrating: %s\n", data);
    return 0;
}

// Simulated persistence mechanism
int establish_persistence(const char *path) {
    printf("[*] Establishing persistence: %s\n", path);
    // In real malware, this might use CreateService, RegSetValue, etc.
    return 0;
}

// Simulated file operations
void scan_directory(const char *path) {
    printf("[*] Scanning directory: %s\n", path);
    // In real malware, this would use FindFirstFile, FindNextFile
}

// Simulated process injection
int inject_into_process(int pid) {
    printf("[*] Injecting into process: %d\n", pid);
    // In real malware, this would use OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread
    return 0;
}

// Configuration parser
ConfigEntry* parse_config(const char *config_data) {
    ConfigEntry *entries = malloc(sizeof(ConfigEntry) * 10);

    entries[0].name = "c2_server";
    entries[0].value = "192.168.1.100";
    entries[0].offset = 0;

    entries[1].name = "c2_port";
    entries[1].value = "8080";
    entries[1].offset = 16;

    entries[2].name = "persistence_key";
    entries[2].value = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    entries[2].offset = 32;

    return entries;
}

// Anti-debugging checks
int check_debugger() {
    // In real malware, this would use IsDebuggerPresent, CheckRemoteDebuggerPresent
    printf("[*] Checking for debugger...\n");
    return 0;
}

// Main malware logic
int main(int argc, char *argv[]) {
    printf("Sample Malware Test Binary\n");
    printf("===========================\n\n");

    // Embedded strings for IOC extraction
    const char *c2_server = "malicious-c2.example.com";
    const char *backup_c2 = "10.0.0.50";
    const char *exfil_url = "https://exfil.badguys.net/upload";
    const char *target_file = "C:\\Windows\\System32\\important.dll";
    const char *reg_key = "HKEY_LOCAL_MACHINE\\Software\\BadSoftware";
    const char *email = "attacker@evil.com";

    // Check for debugger
    if (check_debugger()) {
        printf("[!] Debugger detected, exiting\n");
        return 1;
    }

    // Parse configuration
    ConfigEntry *config = parse_config("encrypted_config_data");

    // Set operation mode
    OperationMode mode = MODE_SCAN;

    switch (mode) {
        case MODE_SCAN:
            scan_directory("C:\\Users");
            scan_directory("C:\\Documents");
            break;

        case MODE_EXFIL:
            connect_c2(c2_server);
            exfiltrate_data("sensitive_data.txt");
            break;

        case MODE_PERSIST:
            establish_persistence(target_file);
            break;

        default:
            printf("[*] Idle mode\n");
            break;
    }

    // Encrypt some data
    unsigned char data[] = "SecretPayload";
    xor_encrypt(data, sizeof(data), 0xAA);
    printf("[*] Encrypted payload: ");
    for (size_t i = 0; i < sizeof(data); i++) {
        printf("%02x ", data[i]);
    }
    printf("\n");

    // Simulate process injection
    inject_into_process(1234);

    // Cleanup
    free(config);

    printf("\n[+] Test completed successfully\n");
    return 0;
}
